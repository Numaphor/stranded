---
phase: 01-foundation-validation
plan: 06
type: execute
wave: 2
depends_on: ["01-01", "01-02", "01-03", "01-04", "01-05"]
files_modified:
  - src/validation/integration/system_validation.cpp
  - src/validation/integration/system_validation.h
  - src/core/world.cpp
autonomous: true
user_setup: []

must_haves:
  truths:
    - "All existing collision detection remains fully functional with chunk streaming"
    - "Entity positioning stays accurate during all chunk loading/unloading operations"
    - "Complete system integration maintains 60 FPS performance baseline"
  artifacts:
    - path: "src/validation/integration/system_validation.cpp"
      provides: "Comprehensive system integration testing"
      exports: ["test_collision_compatibility", "validate_entity_positioning", "measure_system_performance"]
    - path: "src/validation/integration/system_validation.h"
      provides: "Integration validation interface"
      contains: "System-wide testing and compatibility definitions"
    - path: "src/core/world.cpp"
      provides: "Integrated world system with chunk streaming"
      contains: "Complete game loop integration"
  key_links:
    - from: "src/core/world.cpp"
      to: "src/validation/integration/system_validation.cpp"
      via: "integration testing during game loop execution"
      pattern: "measure_system_performance.*update"
    - from: "src/validation/integration/system_validation.cpp"
      to: "All validation subsystems"
      via: "comprehensive integration testing"
      pattern: "test_collision_compatibility.*chunk_manager"
---

<objective>
Validate complete system integration to ensure all existing game systems remain fully functional with enhanced chunk streaming.

Purpose: Confirm that chunk streaming enhancements don't break collision, entity positioning, or overall game performance
Output: Fully validated integrated system maintaining all existing functionality with new chunk streaming capabilities
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@src/core/world.cpp
@src/core/chunk_manager.cpp
@include/str_chunk_manager.h
@include/str_constants.h
@.planning/research/PHASE1-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement System Integration Validation</name>
  <files>src/validation/integration/system_validation.h src/validation/integration/system_validation.cpp</files>
  <action>
Create comprehensive system integration validation framework:

1. Create src/validation/integration/system_validation.h:
   - Define integration test categories: COLLISION, ENTITIES, PERFORMANCE
   - Declare comprehensive system validation functions
   - Include baseline performance metrics for regression testing
   
2. Create src/validation/integration/system_validation.cpp:
   - Implement test_collision_compatibility() for collision system validation
   - Add validate_entity_positioning() for entity coordinate accuracy
   - Create measure_system_performance() for complete system benchmarking
   
   Based on research integration testing patterns:
   ```cpp
   void test_collision_compatibility() {
       // Test collision detection with chunk streaming
       BN_LOG_LEVEL(bn::log_level::INFO, "COLLISION_TEST: baseline vs streaming");
       
       // Measure collision accuracy with static chunks
       // Measure collision accuracy during active streaming
       // Compare results to ensure no regressions
   }
   
   void validate_entity_positioning() {
       // Test entity positions remain accurate during chunk operations
       BN_LOG_LEVEL(bn::log_level::INFO, "ENTITY_TEST: position accuracy");
       
       // Track entity coordinates during buffer recentering
       // Validate world-to-screen transformations
       // Ensure hitbox calculations remain correct
   }
   ```

3. Implement regression testing framework:
   - Establish baseline metrics for all game systems
   - Create automated comparison tests
   - Detect performance degradation or functional regressions

Based on research: systematic edge case matrix ensures comprehensive integration coverage.
</action>
  <verify>Integration validation framework detects all system compatibility issues</verify>
  <done>Comprehensive integration testing covers all critical game systems</done>
</task>

<task type="auto">
  <name>Task 2: Validate Collision System Compatibility</name>
  <files>src/core/world.cpp src/validation/integration/system_validation.cpp</files>
  <action>
Validate that collision detection remains fully functional with chunk streaming:

1. Review existing collision system integration:
   - Locate collision detection calls in world.cpp update loop
   - Verify collision data comes from chunk_manager::get_tile_at_world()
   - Check that collision grid updates properly with streaming chunks

2. Implement collision compatibility testing:
   ```cpp
   void test_collision_compatibility() {
       // Test static collision baseline
       test_static_collision_patterns();
       
       // Test collision during active streaming
       test_streaming_collision_accuracy();
       
       // Test collision at buffer boundaries
       test_buffer_edge_collision();
   }
   
   void test_streaming_collision_accuracy() {
       // Force active chunk streaming while testing collision
       chunk_manager.set_stress_test_mode(true);
       
       // Run collision test patterns during streaming
       for (int i = 0; i < 1000; ++i) {
           bn::fixed_point test_pos = get_random_world_position();
           bool collision = check_collision_at(test_pos);
           
           // Log collision accuracy during streaming
           BN_LOG_LEVEL(bn::log_level::DEBUG, "COLLISION_STREAMING:", 
                        test_pos.x(), ",", test_pos.y(), "->", collision ? "BLOCK" : "FREE");
       }
   }
   ```

3. Validate collision data consistency:
   - Ensure tile data from chunk_manager matches world collision grid
   - Test collision detection during chunk loading/unloading transitions
   - Verify no temporary collision artifacts during buffer operations

4. Performance validation:
   - Measure collision detection overhead with streaming
   - Ensure 60 FPS maintenance during collision + streaming
   - Test worst-case scenarios (many entities + active streaming)

Based on requirement: ensure all existing collision detection remains fully functional.
</action>
  <verify>Collision detection accuracy remains 100% during all chunk streaming operations</verify>
  <done>Collision system performance impact is minimal (< 3% frame time)</done>
</task>

<task type="auto">
  <name>Task 3: Validate Entity and Camera System Integration</name>
  <files>src/core/world.cpp src/validation/integration/system_validation.cpp</files>
  <action>
Validate entity positioning and camera system compatibility with chunk streaming:

1. Test entity positioning accuracy:
   ```cpp
   void validate_entity_positioning() {
       // Track entity coordinates during all chunk operations
       BN_LOG_LEVEL(bn::log_level::INFO, "ENTITY_POSITION_TEST: baseline vs streaming");
       
       // Test entities at various world positions
       for (auto& entity : entities) {
           bn::fixed_point world_pos = entity.position();
           bn::fixed_point buffer_pos = chunk_manager.world_to_buffer(world_pos);
           
           // Validate coordinate conversion accuracy
           BN_ASSERT(buffer_pos.x() >= 0 && buffer_pos.x() < str::VIEW_BUFFER_TILES * str::TILE_SIZE,
                     "Entity X coordinate out of buffer bounds");
           BN_ASSERT(buffer_pos.y() >= 0 && buffer_pos.y() < str::VIEW_BUFFER_TILES * str::TILE_SIZE,
                     "Entity Y coordinate out of buffer bounds");
       }
   }
   ```

2. Validate camera system integration:
   - Test camera smooth following with active chunk streaming
   - Verify camera deadzone behavior during buffer recentering
   - Test camera lookahead with chunk loading delays

3. Test entity-chunk interactions:
   - Validate entity spawning works correctly with streamed chunks
   - Test entity movement across chunk boundaries
   - Ensure entity collision works with newly loaded chunks

4. Performance and visual validation:
   - Measure entity system overhead with streaming
   - Test for visual artifacts during entity movement + streaming
   - Validate frame rate during complex entity scenarios + streaming

5. Stress testing:
   - Maximum entity count with active streaming
   - Rapid entity movement across chunk boundaries
   - Complex camera movements during intense streaming

Based on requirement: ensure all entity positioning and camera systems remain fully functional.
</action>
  <verify>Entity positioning accuracy remains 100% during all chunk operations</verify>
  <done>Camera system maintains smooth behavior during active chunk streaming</done>
</task>

</tasks>

<verification>
Run comprehensive integration validation tests:
- Collision system: test accuracy during active streaming
- Entity positioning: validate coordinate accuracy across all operations
- Camera system: ensure smooth following with chunk operations
- Performance: measure complete system impact
- Regression testing: compare baseline vs enhanced functionality
</verification>

<success_criteria>
1. All existing collision detection remains fully functional with chunk streaming
2. Entity positioning stays accurate during all chunk loading/unloading operations
3. Camera system maintains smooth behavior during active chunk streaming
4. Complete system integration maintains 60 FPS performance baseline
5. No visual artifacts or gameplay regressions with enhanced chunk system
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-validation/01-06-SUMMARY.md`
</output>