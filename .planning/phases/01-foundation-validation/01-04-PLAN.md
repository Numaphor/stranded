---
phase: 01-foundation-validation
plan: 04
type: execute
wave: 1
depends_on: []
files_modified:
  - src/core/chunk_manager.cpp
  - src/validation/coords/coord_validation.cpp
  - src/validation/coords/coord_validation.h
autonomous: true
user_setup: []

must_haves:
  truths:
    - "World-to-buffer coordinate conversion accurately handles wrapping for all player positions"
    - "Buffer coordinate wrapping works seamlessly across 16x16 buffer boundaries"
    - "Buffer origin tracking remains consistent during all world positions"
  artifacts:
    - path: "src/core/chunk_manager.cpp"
      provides: "World-to-buffer and buffer-to-world coordinate conversion"
      contains: "world_to_buffer", "buffer_to_world"
    - path: "src/validation/coords/coord_validation.cpp"
      provides: "Comprehensive coordinate conversion testing and validation"
      exports: ["test_coordinate_wrapping", "validate_edge_cases", "track_origin_consistency"]
    - path: "src/validation/coords/coord_validation.h"
      provides: "Coordinate validation interface with boundary testing"
      contains: "WRAP_TEST_BOUNDARIES and BUFFER_SIZE constants"
  key_links:
    - from: "src/core/chunk_manager.cpp"
      to: "src/validation/coords/coord_validation.cpp"
      via: "coordinate conversion validation calls"
      pattern: "validate_edge_cases.*world_to_buffer"
    - from: "src/validation/coords/coord_validation.cpp"
      to: "mGBA logging system"
      via: "coordinate transformation logging"
      pattern: "BN_LOG_LEVEL.*COORD_CONV"
---

<objective>
Validate and instrument coordinate conversion system to ensure accurate world-to-buffer transformations with seamless wrapping.

Purpose: Confirm coordinate arithmetic handles all edge cases at buffer and world boundaries
Output: Robust coordinate conversion system with comprehensive boundary validation
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@src/core/chunk_manager.cpp
@include/str_chunk_manager.h
@include/str_constants.h
@.planning/research/PHASE1-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement Coordinate Conversion Validation</name>
  <files>src/validation/coords/coord_validation.h src/validation/coords/coord_validation.cpp</files>
  <action>
Create comprehensive coordinate conversion validation based on research patterns:

1. Create src/validation/coords/coord_validation.h:
   - Define buffer size constants: VIEW_BUFFER_TILES (128), VIEW_BUFFER_CHUNKS (16)
   - Declare wrap test boundaries: MAX_WORLD_COORD (8191), MIN_WORLD_COORD (0)
   - Include validation functions for edge case testing
   
2. Create src/validation/coords/coord_validation.cpp:
   - Implement test_coordinate_wrapping() for buffer boundary testing
   - Add validate_edge_cases() for world boundary scenarios
   - Create track_origin_consistency() for buffer origin monitoring
   
   Based on research coordinate validation pattern:
   ```cpp
   void test_coordinate_wrapping() {
       // Test at maximum world coordinates
       bn::fixed_point max_world(WORLD_WIDTH_PIXELS - 1, WORLD_HEIGHT_PIXELS - 1);
       bn::fixed_point buffer_pos = world_to_buffer(max_world);
       
       // Should wrap to buffer coordinates (0-511)
       BN_LOG_LEVEL(bn::log_level::DEBUG, "MAX_COORD:", max_world.x(), ",", max_world.y(), 
                    "-> BUFFER:", buffer_pos.x(), ",", buffer_pos.y());
   }
   ```

3. Implement boundary condition testing:
   - Test wrapping at buffer edges: (511,511) -> (0,0) buffer coordinates
   - Validate negative coordinate handling (though world coordinates are positive)
   - Test coordinate precision for bn::fixed vs integer calculations

Based on research pitfall #3: use proven circular buffer arithmetic with proper bounds checking.
</action>
  <verify>Coordinate conversions handle all boundary cases correctly</verify>
  <done>World-to-buffer transformations work seamlessly at all positions</done>
</task>

<task type="auto">
  <name>Task 2: Enhance Coordinate Conversion Implementation</name>
  <files>src/core/chunk_manager.cpp</files>
  <action>
Review and enhance existing coordinate conversion functions:

1. Analyze current world_to_buffer() implementation:
   - Verify positive_mod() function handles all arithmetic correctly
   - Check that buffer origin tracking (_buffer_origin_tile_x/y) updates properly
   - Ensure tile_to_buffer_coord() conversion matches chunk_to_buffer_slot()

2. Strengthen coordinate arithmetic:
   - Add bounds checking for world coordinate overflow (beyond 8192 pixels)
   - Validate that buffer coordinates stay within 0-511 range
   - Ensure consistent use of TILE_SIZE (8) in all conversions
   
   Review existing conversion logic:
   ```cpp
   // Current positive_mod implementation - verify correctness
   [[nodiscard]] int positive_mod(int value, int modulus) {
       int result = value % modulus;
       if (result < 0) {
           result += modulus;
       }
       return result;
   }
   ```

3. Add buffer origin validation:
   - Track buffer origin changes during player movement
   - Ensure origin updates happen at correct threshold boundaries
   - Validate that buffer origin and player coordinates stay synchronized

Based on research: ensure no unsigned arithmetic overflow in buffer boundary calculations.
</action>
  <verify>Coordinate conversions maintain accuracy during continuous player movement</verify>
  <done>Buffer wrapping arithmetic works correctly at all world positions</done>
</task>

<task type="auto">
  <name>Task 3: Create Comprehensive Edge Case Testing</name>
  <files>src/validation/coords/coord_validation.cpp</files>
<action>
Implement exhaustive coordinate conversion edge case testing:

1. Create systematic test matrix:
   - Test all four world corners: (0,0), (8191,0), (0,8191), (8191,8191)
   - Test buffer boundary transitions: wrapping at 511->0 coordinates
   - Test large coordinate values: maximum world positions

2. Implement precision validation:
   - Test bn::fixed_point precision vs integer coordinate calculations
   - Verify no precision loss in coordinate transformations
   - Validate that chunk and tile coordinate conversions remain consistent

3. Add automated regression testing:
   ```cpp
   void validate_coordinate_transformations() {
       // Test bidirectional conversion consistency
       bn::fixed_point world_pos(100, 200);
       bn::fixed_point buffer_pos = world_to_buffer(world_pos);
       bn::fixed_point back_to_world = buffer_to_world(buffer_pos);
       
       BN_LOG_LEVEL(bn::log_level::INFO, "COORD_CONV:", world_pos.x(), ",", world_pos.y(),
                    "->", buffer_pos.x(), ",", buffer_pos.y(),
                    "->", back_to_world.x(), ",", back_to_world.y());
   }
   ```

4. Stress test coordinate calculations:
   - Rapid movement across buffer boundaries
   - Continuous operation at world edges
   - Performance impact measurement of coordinate overhead

Based on research: systematic edge case matrix ensures comprehensive coverage.
</action>
  <verify>All coordinate conversions pass comprehensive edge case testing</verify>
  <done>Coordinate system operates reliably under all movement patterns</done>
</task>

</tasks>

<verification>
Run comprehensive coordinate validation tests:
- World boundary testing: all four corners and edges
- Buffer wrapping testing: seamless transitions at 511->0 boundaries  
- Bidirectional conversion: world->buffer->world consistency
- Precision testing: bn::fixed vs integer calculations
- Performance testing: coordinate calculation overhead measurement
</verification>

<success_criteria>
1. World-to-buffer coordinate conversion accurately handles wrapping for all player positions
2. Buffer coordinate wrapping works seamlessly across 16x16 buffer boundaries
3. Buffer origin tracking remains consistent during all world positions
4. Coordinate arithmetic uses optimal integer operations without overflow
5. Performance impact of coordinate calculations is minimal (< 2% frame time)
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-validation/01-04-SUMMARY.md`
</output>