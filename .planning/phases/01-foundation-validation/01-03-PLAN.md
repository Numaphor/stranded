---
phase: 01-foundation-validation
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - src/core/chunk_manager.cpp
  - src/validation/dma/dma_validation.cpp
  - src/validation/dma/dma_validation.h
autonomous: true
user_setup: []

must_haves:
  truths:
    - "DMA channel 0 operates during VBlank periods maintaining 60 FPS performance"
    - "Transfer rates stay within 64 tiles/frame bandwidth limit consistently"
    - "Batch tile transfers minimize DMA setup overhead effectively"
  artifacts:
    - path: "src/core/chunk_manager.cpp"
      provides: "DMA transfer implementation for chunk streaming"
      contains: "commit_to_vram"
    - path: "src/validation/dma/dma_validation.cpp"
      provides: "Comprehensive DMA performance validation and logging"
      exports: ["measure_dma_performance", "validate_vblank_timing", "test_batch_efficiency"]
    - path: "src/validation/dma/dma_validation.h"
      provides: "DMA validation interface with hardware constants"
      contains: "DMA channel and VBlank timing definitions"
  key_links:
    - from: "src/core/chunk_manager.cpp"
      to: "src/validation/dma/dma_validation.cpp"
      via: "DMA transfer performance measurement calls"
      pattern: "measure_dma_performance.*commit_to_vram"
    - from: "src/validation/dma/dma_validation.cpp"
      to: "mGBA benchmarking system"
      via: "cycle-accurate timing measurements"
      pattern: "mgba_printf.*DMA_PERF"
---

<objective>
Validate and optimize DMA transfer infrastructure for reliable 64 tiles/frame VRAM updates during VBlank.

Purpose: Ensure DMA transfers maintain 60 FPS performance while respecting GBA hardware bandwidth limits
Output: Optimized DMA transfer system with comprehensive performance validation
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@src/core/chunk_manager.cpp
@include/str_chunk_manager.h
@include/str_constants.h
@.planning/research/PHASE1-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement DMA Performance Validation</name>
  <files>src/validation/dma/dma_validation.h src/validation/dma/dma_validation.cpp</files>
  <action>
Create comprehensive DMA transfer validation based on research patterns:

1. Create src/validation/dma/dma_validation.h:
   - Define DMA channel constants (DMA_CHANNEL_0 for background updates)
   - Include VBlank timing constants and TILES_PER_FRAME limit (64)
   - Declare validation functions with cycle-accurate measurement interfaces
   
2. Create src/validation/dma/dma_validation.cpp:
   - Implement measure_dma_performance() using mGBA benchmarking from research
   - Add validate_vblank_timing() to ensure transfers only during VBlank periods
   - Create test_batch_efficiency() to optimize DMA setup overhead
   
   Based on research VBlank DMA pattern:
   ```cpp
   void measure_dma_performance() {
       // Wait for VBlank start (research pattern)
       while(!REG_VCOUNT & (1 << 0));
       
       uint32_t start_cycles = bn::hw::timer::cycles();
       // Execute DMA transfer
       uint32_t end_cycles = bn::hw::timer::cycles();
       
       BN_LOG_LEVEL(bn::log_level::INFO, "DMA_PERF: ", tiles_transferred, 
                    " tiles in ", (end_cycles - start_cycles), " cycles");
   }
   ```

3. Implement GBA hardware compliance checks:
   - Verify DMA uses 32-bit transfers (not byte writes - research pitfall #1)
   - Validate channel selection (DMA 0 vs 3 performance comparison)
   - Ensure alignment with GBA memory access patterns
</action>
  <verify>DMA transfers complete within VBlank periods consistently</verify>
  <done>DMA performance metrics show efficient tile transfer rates</done>
</task>

<task type="auto">
  <name>Task 2: Optimize Current DMA Transfer Implementation</name>
  <files>src/core/chunk_manager.cpp</files>
  <action>
Review and optimize the existing commit_to_vram() implementation:

1. Analyze current DMA usage in commit_to_vram():
   - Verify TILES_PER_FRAME (64) limit is enforced
   - Check that transfers use appropriate DMA channel for background updates
   - Ensure proper VBlank synchronization (research pitfall #2)

2. Implement DMA timing improvements:
   - Add VBlank wait before any DMA operations (research pattern)
   - Optimize batch size for DMA setup vs transfer time tradeoff
   - Ensure 32-bit word transfers (6 cycles/word from research)
   
   Based on research DMA timing analysis:
   ```cpp
   // ROM-to-VRAM DMA: 6 cycles per 32-bit word
   // 64 tiles = 32KB = 8192 words = 49,152 cycles â‰ˆ 8 scanlines
   void commit_to_vram() {
       // Wait for VBlank start
       while(!REG_VCOUNT & (1 << 0));
       
       // Execute DMA transfer within VBlank window
       REG_DMA3SAD = (uint32_t)source_data;
       REG_DMA3DAD = (uint32_t)VRAM_ADDR;
       REG_DMA3CNT_L = DMA_DST_FIXED | DMA_SRC_INC | DMA_32 | DMA_START_NOW;
   }
   ```

3. Add bandwidth validation:
   - Ensure transfers never exceed 64 tiles/frame limit
   - Verify no frame drops during intensive chunk operations
   - Test DMA performance under worst-case loading scenarios
</action>
  <verify>Frame rate remains stable at 60 FPS during all DMA operations</verify>
  <done>DMA transfers respect hardware bandwidth limits without frame drops</done>
</task>

<task type="auto">
  <name>Task 3: Create DMA Batch Transfer Testing</name>
  <files>src/validation/dma/dma_validation.cpp</files>
  <action>
Implement comprehensive batch transfer optimization testing:

1. Create batch efficiency analysis:
   - Test optimal tile counts per DMA transfer (1-64 tiles range)
   - Measure DMA setup overhead vs transfer time tradeoffs
   - Validate that batching improves overall throughput

2. Implement stress testing scenarios:
   - Maximum load: 64 tiles transferred every frame
   - Variable load: 16, 32, 48, 64 tiles in different patterns
   - Continuous operation: sustained transfers over multiple frames

3. Add automated performance validation:
   - Verify transfers complete within VBlank window (approximately 280 scanlines)
   - Test with Butano HDMA vs regular DMA performance comparison
   - Validate against research benchmark patterns

   Use mGBA headless benchmarking from research:
   ```cpp
   // Based on research: mgba_printf for automated CI integration
   mgba_printf(MGBA_LOG_INFO, "BENCHMARK: %d cycles", transfer_duration);
   mgba_printf(MGBA_LOG_INFO, "TILES_FRAME: %d", tiles_transferred);
   mgba_printf(MGBA_LOG_INFO, "BANDWIDTH_UTIL: %d%%", bandwidth_usage);
   ```

4. Create performance regression tests:
   - Establish baseline performance metrics
   - Detect performance degradation in future changes
   - Validate consistency across different GBA emulators
</action>
  <verify>Batch transfer optimization shows measurable performance improvements</verify>
  <done>DMA system operates within 64 tiles/frame budget with optimal efficiency</done>
</task>

</tasks>

<verification>
Run comprehensive DMA validation tests:
- VBlank timing verification: transfers only during safe periods
- Bandwidth limit testing: never exceed 64 tiles/frame
- Batch optimization: compare 1-tile vs 64-tile transfer efficiency
- Stress testing: maximum sustained transfer rates
- Performance regression: ensure no degradation over time
</verification>

<success_criteria>
1. DMA channel 0 operations occur exclusively during VBlank periods
2. Transfer rates consistently stay within 64 tiles/frame hardware bandwidth limit
3. Batch tile transfers minimize DMA setup overhead effectively
4. Frame rate maintains stable 60 FPS during all chunk streaming operations
5. Performance metrics establish reliable baseline for future optimization
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-validation/01-03-SUMMARY.md`
</output>